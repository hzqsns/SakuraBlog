---
title: LeetCode 862. 和至少为 K 的最短子数组
excerpt: '' 
author: Sakura
publishDate: '2025-01-22'
coverImage: 'http://www.hzqsns.com/wp-content/uploads/2024/06/20210316155221.jpg' 
slug: 'LeetCode-862'
date: 2025-01-22 13:08:00
tags:
  - 前缀和
  - 单调队列
category:
  - 算法题
  - LeetCode
---
![](http://www.hzqsns.com/wp-content/uploads/2024/06/Snipaste_2024-06-03_15-30-13.png)

* 思路：我们先计算前缀和，然后我们要找到一个前缀和区间[i,j]，满足s[j] - s[i] >= K，且i - j 要最小
    * 如果当前前缀和数组是单调的就很好做了，但是这个题里面的数有的是正的有的是负的，所以前缀和肯定不是单调的，但是我们依然可以利用单调队列来创造出单调性
    * 所以我们定义一个双向队列，往右边依次插入每个s[i]，如果队列的右边大于s[i]，那么就一直出队直到队列单调为止，因为我们的目的是找对于每一个s[i]，我们要找到一个j使得s[i] - s[j] >= k且j越大越好
    * **所以我们从队列的左边开始判断是否符合条件然后再让队头出队**(因为当前队列是单调的此时s[i] - s[j] >= k，那么后面比如还有更大的数进入队列比如s[i+1] > s[i]，那么s[i + 1] - s[j] >= k显然成立，所以此时s[j]就相当于没啥用了直接出队就行)

```
        因为对于暴力的做法对于区间(0,i],我们会到(0,i)从右到左依次遍历
        看是否有满足条件的t属于(0,i)使得s[i] - s[t] >= K
        (s[i] - s[t]对应区间[t+1,i],即等价于(s[i] - s[(t+1)-1]))

        根据这个性质我们可以定义一个单调队列，这个单调队列中存放前缀和s[i]的下标i
        且这个单调队列中的下标对应前缀和是依次递增的
        因为单调队列中我们是从左往右插入的(左对应队头，右对应队尾)
        那么对应区间(0,i]中对应的两个值s[x]和s[x+1]
        如果s[x] >= s[x+1] 那么s[x]就没有存在的意义了，因为对于我们往后再继续遍历的话
        s[x+1]比s[x]更小，那么我往后如果要求和大于K的区间
        (我们的目标是要找到s[i] - s[x] >= k,如果s[x+1] <= s[x]的话
        那么凑手s[i] - s[x+1] >= k,且明显[x+1,i]这个区间更短)


        如果s[i] - s[x] >= k,且s[i] - s[x+1] >= k
        那我为什么不选x+1呢，因为x+1更靠右，对应的子数组长度肯定更短
class Solution {
public:
    typedef long long LL;
    int shortestSubarray(vector<int>& nums, int k) {
        int n = nums.size();
        int ans = n+1;//最大的长度为n+1
        vector<LL>s(n+1,0);//对应数据10^5 * 10^5 = 10^10会爆int，这里用longlong来存储
        for(int i = 1;i <= n;i++)
        {
            s[i] = s[i-1] + nums[i-1];
        }
        
        deque<int> q;
        q.push_back(0);//把s[0]先提前push进去
        for(int i = 1;i <= n;i++)
        {
            //首先判断当前遍历到的值是否比单调队列的右边(即队尾)要大
            //如果更大，就一直弹出队尾的值，以便后面插入s[i]，形成单调递增的队列
            while(q.size() && s[q.back()] >= s[i]) q.pop_back();

            //弹出之后，单调队列里面就都是比s[i]要小的数了
            //这个时候我们其实就是要找右端点为i，然后向左找到符合条件的s[x]且x的下标越大越好
            //这样对应子数组的长度才会最短
            while(q.size() && (s[i] - s[q.front()] >= k))
            {
                //此时满足条件，就直接求最小值
                //s[i] - s[q.front()]其实对应s[i] - s[(q.front()+1) - 1]
                //对应的区间其实是[q.front()+1,i]
                //区间长度为i - (q.front()+1) + 1 = i - q.front()
                ans = min(ans,i - q.front());

                //此时再弹出左边(即队头)的元素
                //因为有可能队头右边的元素也能够满足条件，这样对应的区间更短
                //但是这里为什么要弹出更小的数呢，我个人觉得是因为s[i]能拿来比较，说明s[i]是在不断增大的
                //这样的话原来左边队头的元素如果不弹出的话，那么对应的区间长度肯定更大啊，没有什么意义，所以直接弹出
            
                q.pop_front();
            }
            //每次都还需要插入s[i]对应的下标i
            q.push_back(i);
        }
        return (ans == n+1) ? -1 : ans;
    }
};
```